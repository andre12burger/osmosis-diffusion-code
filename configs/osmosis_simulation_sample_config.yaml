# saving directory
save_dir: results

degamma_input: False # use it for not linear haze image
manual_seed: 0
check_prior: False

save_singles: True # save single reference image, restored RGB image and depth estimation image
save_grids: True
text_on_results: False

# record the sampling process
record_process: True
record_every: 200

# change unet input and output - for RGBD - it is
change_input_output_channels: True
input_channels: 4  # RGBD
output_channels: 8  # RGBD * 2 - learning sigma = True, if False 4

# gibbsDDRM sampling method - the names borrowed from their paper
sample_pattern:

  pattern: pcgs  # original, pcgs - from gibbsDDRM

  # relevant only for "pattern: pcgs"

  # update phi's
  update_start: 0.7
  update_end: 0

  # repeat several times the T steps
  global_N: 1
  # iterative between update x_t and optimizing phis for the same t - time step
  local_M: 1
  s_start: 1
  s_end: 0

  # for each t step, the number of optimization steps for beats and B_inf
  n_iter: 20

  # PGDiff - when to guide? no guidance at all not tin the range
  start_guidance: 1
  stop_guidance: 0


# unet model configurations
unet_model:
  image_size: 256
  num_channels: 256
  num_res_blocks: 2
  channel_mult: ""
  learn_sigma: True
  class_cond: False
  use_checkpoint: False
  attention_resolutions: 32, 16, 8
  num_heads: 4
  num_head_channels: 64
  num_heads_upsample: -1
  use_scale_shift_norm: True
  dropout: 0.0
  resblock_updown: True
  use_fp16: False
  use_new_attention_order: False

  # pretrained model
  model_path: osmosis_outdoor.pt
  pretrain_model: osmosis  # osmosis, imagenet

# diffusion configurations
diffusion:
  sampler: ddpm
  steps: 1000
  noise_schedule: linear # linear, cosine
  model_mean_type: epsilon
  model_var_type: learned_range

  dynamic_threshold: False
  clip_denoised: False
  min_max_denoised: False

  rescale_timesteps: False
  timestep_respacing: 1000

# task configurations
conditioning:
  method: osmosis # osmosis, ps - for checking the prior
  params:
    loss_function: norm # norm, mse

    loss_weight: depth # none, depth # if "none" so the rest has no meaning
    weight_function: gamma,1.4,1.4,1 # function, value

    # when measurement operator noise (check_prior) is not underwater - set scale for depth to 0 (vR,vG,vB,vD=0)
    scale: 4,4,4,1 # osmosis
    gradient_x_prev: True # if False - the gradient of the forward degradation is according x_0_pred

    gradient_clip: True,0.001

# specify the loss and its weight/scale, if not specified so no auxiliary loss
aux_loss:
  aux_loss:
#    avrg_loss: 0
    val_loss: 40

data:
  batch_size: 1

  name: simulation
#  root: ./data/simulation_1/input
#  gt_rgb: ./data/simulation_1/gt_rgb
#  gt_depth: ./data/simulation_1/gt_depth
  root: ./data/simulation_2/input
  gt_rgb: ./data/simulation_2/gt_rgb
  gt_depth: ./data/simulation_2/gt_depth
  stop_after: -1
  ground_truth: True

measurement:
  operator:

    name: underwater_physical

    optimizer: sgd # GD, adam, sgd

    # does not matter for not underwater
    depth_type: original # original- [0,1], gamma=((x+value[0])*value[1])^value[2]
    value: 1.4,1.4,1

    # underwater_physical
    phi_ab: 1.1,0.95,0.95
    phi_ab_eta: 1e-5
    phi_ab_learn_flag: True

    # underwater_physical, haze_physical
    phi_inf: 0.2,0.4,0.7
    phi_inf_eta: 1e-5
    phi_inf_learn_flag: True

  noise:
    name: clean # clean - osmosis, gaussian - ps
#    sigma: 0.001 # gaussian - ps



